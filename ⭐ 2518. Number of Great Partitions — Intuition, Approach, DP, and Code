class Solution {
    static final long MOD = 1_000_000_007;

    public int countPartitions(int[] nums, int k) {
        long sum = 0;
        for (int x : nums) sum += x;

        // If total sum < 2k, it's impossible for both groups to reach sum >= k
        if (sum < 2L * k) return 0;

        int n = nums.length;

        long[] dp = new long[k];
        dp[0] = 1;

        // Count subsets with sum < k
        for (int x : nums) {
            for (int s = k - 1; s >= x; s--) {
                dp[s] = (dp[s] + dp[s - x]) % MOD;
            }
        }

        long bad = 0;
        for (int s = 0; s < k; s++) {
            bad = (bad + dp[s]) % MOD;
        }

        // Total possible partitions: 2^n
        long total = modPow(2, n, MOD);

        // Good = total - 2 * bad
        long ans = (total - (2 * bad) % MOD + MOD) % MOD;

        return (int) ans;
    }

    private long modPow(long base, long exp, long mod) {
        long result = 1;
        while (exp > 0) {
            if ((exp & 1) == 1)
                result = (result * base) % mod;
            base = (base * base) % mod;
            exp >>= 1;
        }
        return result;
    }
}
